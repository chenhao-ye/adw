#!/usr/bin/env python3
import os
import strictyaml
from strictyaml import Map, Str, Seq, MapPattern, Bool, Optional, Any
from collections import OrderedDict
from typing import List, Dict, Mapping, Set
import logging
import re

# signal files
FNAME_DONE = os.environ["ADW_FNAME_DONE"]
FNAME_CMD = os.environ["ADW_FNAME_CMD"]
FNAME_HELP = os.environ["ADW_FNAME_HELP"]
DNAME_DEPS = os.environ["ADW_DNAME_DEPS"]
CMDS_DIR = os.environ["ADW_PROJ_CMDS_DIR"]  # relative to PROJ_ROOT_DIR
CONFIG_FNAME = os.environ['ADW_PROJ_CONFIG']


class ADWConfigError(Exception):
    pass


def load_config():
    with open(CONFIG_FNAME) as f:
        config_file = f.read()

    schema = Map({
        "adw_meta":
        Map({
            "pred":
            Seq(
                MapPattern(
                    Str(),
                    Map({
                        "help": Str(),
                        Optional("is_exclusive", default=False): Bool(),
                        Optional("pass_unmatched_args", default=False): Bool(),
                    }))),
            Optional("env"):
            Seq(MapPattern(Str(), Str())),
        }),
        "adw_cmds":
        MapPattern(Str(), Any())
    })

    # will report errors if schema not match
    return strictyaml.load(config_file, schema=schema).data


def check_name(name: str):
    if re.compile('^[a-zA-Z0-9_-]+$').fullmatch(name) is None:
        raise ADWConfigError(f'Invalid Predicate or Target name: "{name}"')


def dump_env(config: Dict) -> None:
    if "env" not in config["adw_meta"]:
        return
    with open(os.environ["ADW_PROJ_ENV"], "wt") as f:
        f.write("#!/bin/bash\n")
        f.write("# Generated by ADW. DO NOT MODIFY.\n")
        f.write(f"# If any change is needed, update {CONFIG_FNAME} instead.\n")
        for env_dict in config["adw_meta"]["env"]:
            for k, v in env_dict.items():  # actually only one element
                f.write(f"{k}={v}\n")


class Target:
    def __init__(self,
                 name: str,
                 prefix: List['Target'],
                 pred: 'Pred',
                 deps: Set['Target'],
                 cmd=None) -> None:
        self.name = name
        self.prefix = prefix
        self.pred = pred
        self.deps = deps
        self.cmd = cmd
        self.subtargets = None
        self.is_immed = False

    def set_subtargets(self, subtargets: Dict[str, 'Target']):
        self.subtargets = subtargets

    def set_is_immed(self):
        assert self.cmd is not None
        assert self.subtargets is None
        self.is_immed = True

    # this essentially return a path-style name
    def __str__(self) -> str:
        if self.is_immed:
            return self.pred.name
        return "/".join([self.pred.name] + self.prefix + [self.name])

    @property
    def is_leaf(self) -> bool:
        return self.cmd is not None

    @property
    def is_always_done(self) -> bool:  # a special control cmd
        return self.is_leaf and self.cmd == "ADW_ALWAYS_DONE"

    def query_target_for_deps(self, path: List[str]) -> Set['Target']:
        if self.is_leaf:
            if self.is_always_done:
                return set()
            return {self}
        if len(path) == 0:
            ret = set()
            for t in self.subtargets.values():
                ret.update(t.query_target_for_deps(path))
            return ret
        ele = path[0]
        if ele not in self.subtargets:
            raise ADWConfigError(
                f'Target "{ele}" not found in target "{self.pred}/{self}"')
        return self.subtargets[ele].query_target_for_deps(path[1:])

    def dump(self) -> None:
        if not self.is_immed:
            os.mkdir(f"{CMDS_DIR}/{self}")
            logging.debug(f"make target: {CMDS_DIR}/{self}")
        if not self.is_leaf:
            for t in self.subtargets.values():
                t.dump()
        else:
            if self.is_always_done:
                with open(f"{CMDS_DIR}/{self}/{FNAME_CMD}", "w") as f:
                    pass
            with open(f"{CMDS_DIR}/{self}/{FNAME_CMD}", "w") as f:
                self.gen_code(f, f"{self}")
                logging.debug(f"gen code: {self.cmd}")
            if len(self.deps) > 0:
                os.mkdir(f"{CMDS_DIR}/{self}/{DNAME_DEPS}")
                for d in self.deps:
                    link_dst_path = f"{CMDS_DIR}/{self}/{DNAME_DEPS}/{str(d).replace('/', ':')}"
                    link_src_path = f"{CMDS_DIR}/{d}"
                    link_src_relpath = os.path.relpath(
                        link_src_path, f"{CMDS_DIR}/{self}/{DNAME_DEPS}")
                    os.symlink(link_src_relpath, link_dst_path)
                    logging.debug(
                        f"sym link: {link_dst_path} -> {link_src_relpath}")

    def gen_code(self, f, target_dir: str) -> None:
        assert self.is_leaf
        config_str = "#"
        if self.pred.is_exclusive:
            config_str = f"{config_str} adw_is_exclusive"
        if self.pred.pass_unmatched_args:
            config_str = f"{config_str} adw_pass_unmatched_args"
        f.write(f"{config_str}\n")
        f.write(f'{self.cmd}')
        if self.pred.pass_unmatched_args:
            f.write(' "$@"')
        f.write("\n")


class Pred:
    def __init__(self, name, dep, param: Dict) -> None:
        self.name = name
        self.dep = dep
        self.help = param["help"]  # "help" is required
        self.is_exclusive = param.get("is_exclusive", False)
        self.pass_unmatched_args = param.get("pass_unmatched_args", False)
        self.targets = {}
        self.immed_target = None

    def set_targets(self, targets: Target) -> None:
        assert self.immed_target is None
        self.targets = targets

    def set_immed_target(self, target: Target) -> None:
        assert len(self.targets) == 0
        self.immed_target = target
        target.set_is_immed()

    def __str__(self) -> str:
        return self.name

    @property
    def is_leaf(self) -> bool:
        return self.immed_target is not None

    def query_target_for_deps(self, path: List[str]) -> Set[Target]:
        if self.is_leaf:
            if self.immed_target.is_always_done:
                return set()  # empty set
            return {self.immed_target}
        if len(path) == 0:
            ret = set()
            for t in self.targets:
                ret.update(t.query_target_for_deps(path))
            return ret
        ele = path[0]
        if ele not in self.targets:
            raise ADWConfigError(
                f'Target "{ele}" not found in Predicate "{self}"')
        return self.targets[ele].query_target_for_deps(path[1:])

    def dump(self) -> None:
        os.mkdir(f"{CMDS_DIR}/{self}")
        logging.debug(f"make pred: {CMDS_DIR}/{self}")
        if self.is_leaf:
            self.immed_target.dump()
        else:
            for t in self.targets.values():
                t.dump()


def build_target(prefix: List[str],
                 pred: Pred,
                 tname: str,
                 *,
                 sub_config: Dict = None,
                 cmd: str = None):
    # must not both None or not None
    assert (sub_config is None) != (cmd is None)

    if ':' in tname:  # newly declared target
        tname_split = tname.split(":", 1)
        tname_split = [t.strip() for t in tname_split]
        tname, deps_str = tname_split
        deps_str = [prefix + d.strip().split("/") \
            for d in deps_str.split(",")]
    else:  # default is the same target from the last Predicate
        deps_str = [prefix + [tname]]

    check_name(tname)

    deps = set()
    if pred.dep is not None:
        for d in deps_str:
            deps.update(pred.dep.query_target_for_deps(d))

    if cmd is not None:
        return Target(tname, prefix, pred, deps, cmd)
    else:  # sub_config is not None
        t = Target(tname, prefix, pred, deps)
        subtargets = build_target_subtree(prefix + [tname], pred, sub_config)
        t.set_subtargets(subtargets)
        return t


# prefix should exclude Predicate
def build_target_subtree(prefix: List[str], pred: Pred,
                         sub_config: Dict) -> Dict[str, Target]:
    subtree = {}
    for tname, sub_or_cmd in sub_config.items():
        if isinstance(sub_or_cmd, str):
            target = build_target(prefix, pred, tname, cmd=sub_or_cmd)
        elif isinstance(sub_or_cmd, Mapping):
            target = build_target(prefix, pred, tname, sub_config=sub_or_cmd)
        else:
            raise ADWConfigError(
                f'Unknown type in Target "{tname}": {sub_or_cmd}')
        subtree[tname] = target
    return subtree


def build_meta(config: Dict) -> OrderedDict:
    dep = None
    pred_map = OrderedDict()
    for pdict in config["adw_meta"]["pred"]:
        for pname, param in pdict.items():  # only one element actually
            check_name(pname)
            pred = Pred(pname, dep, param)
            pred_map[pname] = pred
            dep = pred
    for p in pred_map.keys():
        if p not in config["adw_cmds"]:
            raise ADWConfigError(
                f'Predicate "{p}" defined in adw_meta, but not found in adw_cmds'
            )
    for p in config["adw_cmds"].keys():
        if p not in pred_map:
            raise ADWConfigError(
                f'Predicate "{p}" defined in adw_cmds, but not found in adw_meta'
            )
    return pred_map


def build_cmds(config: Dict, pred_map: Dict):
    for pname, sub_or_cmd in config["adw_cmds"].items():
        pred = pred_map[pname]
        if isinstance(sub_or_cmd, str):
            pred.set_immed_target(
                build_target([], pred, pred.name, cmd=sub_or_cmd))
        elif isinstance(sub_or_cmd, Mapping):
            pred.set_targets(build_target_subtree([], pred, sub_or_cmd))


if __name__ == "__main__":
    try:
        config = load_config()
        pred_map = build_meta(config)
        build_cmds(config, pred_map)
        for pred in pred_map.values():
            pred.dump()
        # write "help"
        with open(f"{CMDS_DIR}/{FNAME_HELP}", "wt") as f:
            for pred in pred_map.values():
                f.write(f"  {pred.name}: ")
                pname_len = len(pred.name)
                num_space = max((pname_len + 3) // 8 * 8 + 4, 12) - pname_len
                f.write(' ' * num_space)
                f.write(f"{pred.help}\n")
        dump_env(config)
    except strictyaml.YAMLError as e:
        print(f"[ERROR] Fail to parse {CONFIG_FNAME}:")
        print(e)
        exit(1)
    except ADWConfigError as e:
        print(f"[ERROR] Fail to load {CONFIG_FNAME}:")
        print(e)
        exit(1)
    except Exception as e:  # likely system errors e.g. FileExistsError
        print("[ERROR] Fail to load project:")
        print(e)
        exit(1)
